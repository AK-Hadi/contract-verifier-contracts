;; Simplified verifier registry 
;; passes on messages signed by a public key to sources registry

#pragma version >=0.2.0;
#include "imports/stdlib.fc";

(int, slice) load_data() inline {
  var ds = get_data().begin_parse();
  return (
    ds~load_uint(256), ;; pub_key
    ds~load_msg_addr() ;; sources_registry
  );
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
    return ();
  }
  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
    
  if (flags & 1) { ;; ignore all bounced messages
    return ();
  }

  ;; TODO is it interesting to prevent replay?
  ;; TODO skipping op / query id
  var signature = in_msg_body~load_bits(512);
  (int public_key, slice sources_registry_addr) = load_data();
  cell message = in_msg_body~load_ref();
  throw_if(998, slice_empty?(message.begin_parse())); ;; empty messages not allowed
  throw_unless(999, check_signature(cell_hash(message), signature, public_key)); ;; TODO

  var msg = begin_cell()
            .store_uint(0x18, 6) ;; TODO!
            .store_slice(sources_registry_addr)
            .store_coins(msg_value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; TODO understand better + bounce etc.
            .store_uint(0,1)
            .store_uint(1,1)
            .store_ref(message); ;; This ref would contain the code cell hash, then the url in a ref
  send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
  return();
}