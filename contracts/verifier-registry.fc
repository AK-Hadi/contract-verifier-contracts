;; Simplified verifier registry 
;; passes on messages signed by a public key to sources registry

#pragma version >=0.2.0;
#include "imports/stdlib.fc";

const int THIRTY_MIN = 1800;

(int) load_data() inline {
  var ds = get_data().begin_parse();
  return (
    ds~load_uint(256) ;; pub_key
  );
}

;; TODO describe payload
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
    return ();
  }
  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
    
  if (flags & 1) { ;; ignore all bounced messages
    return ();
  }
  ;; TODO skipping op / query id
  ;; TODO error codes

  var valid_from = in_msg_body~load_uint(32);

  throw_if(997, now() > valid_from + THIRTY_MIN);

  var signature = in_msg_body~load_bits(512);
  var to = in_msg_body~load_msg_addr();
  (int public_key) = load_data();
  cell message = in_msg_body~load_ref();
  throw_if(998, slice_empty?(message.begin_parse())); ;; empty messages not allowed
  throw_unless(999, check_signature(cell_hash(message), signature, public_key)); ;; TODO

  var msg = begin_cell()
            .store_uint(0x18, 6) ;; TODO!
            .store_slice(to)
            .store_coins(msg_value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32) ;; TODO understand better + bounce etc.
            .store_uint(0, 1) ;; no stateinit
            .store_uint(1, 1) ;; msg in ref
            .store_ref(message);
  send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
  return();
}